<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React自上而下的学习笔记-----理论篇</title>
    <link href="/2021/02/19/react-learn/"/>
    <url>/2021/02/19/react-learn/</url>
    
    <content type="html"><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>官网提出的：</p><blockquote><p>React是用JavaScript构建<strong>快速响应</strong>的大型Web应用程序的首选方式。它在Facebook和Instagram上的表现优秀。</p></blockquote><p>由此可见，React打造的就是快速响应，但是在我们日常使用APP、浏览器的时候，会因为一些场景造成快速响应被制约：</p><ul><li>CPU的瓶颈：当遇到大计算量的操作或者设备性能不足导致页面掉帧卡顿。</li><li>IO(input/output)的瓶颈: 发送网络请求以后，由于需要等待数据的返回才能进行下一步的操作导致不能快速的响应。</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>众所周知，主流浏览器刷新频率是60HZ，就是(1000ms / 60HZ) 就是16.6ms浏览器刷新一次。<br>但是，GUI渲染线程跟JS线程是互斥的，因此，JS脚本跟浏览器布局、绘制不能同时进行，而在每16.6ms内，需要完成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">JS脚本执行<br>样式布局<br>样式绘制<br></code></pre></td></tr></table></figure><p>所以一旦JS执行时间过长，超出了16.6ms，那么这次的刷新就没有时间执行后面的程序了。</p><p>react为了解决这个问题，在浏览器每一帧的时间中，预留一些时间（预留的时间为5s）给JS线程，而React会利用这个时间更新组件，但是如果预留的时间不能执行完JS，react会把线程的控制权还给浏览器，让其有时间渲染UI，而React就等待下一帧的时间来继续被中断的工作，这个过程就被称为时间切片。</p><p>而React中要使用这个时间切片，就需要开启Concurrent Mode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs React">&#x2F;&#x2F; 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode<br>ReactDOM.unstable_createRoot(rootEl).render(&lt;App &#x2F;&gt;);<br></code></pre></td></tr></table></figure><blockquote><p>所以综上所述，React解决CPU的短板问题，使用了时间切片，而时间切片的关键就是将同步的更新变成可以中断的异步更新。</p></blockquote><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端知识点的杂记</title>
    <link href="/2021/02/18/react1/"/>
    <url>/2021/02/18/react1/</url>
    
    <content type="html"><![CDATA[<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><blockquote><p>目前主流的盒模型分为两类：</p><ol><li>W3C标准盒模型：content + padding + border + margin</li><li>IE盒模型: content(content + padding + border) + margin</li></ol><p>盒模型是可以通过box-sizing设置：<br>content-box (W3C标准盒模型)<br>border-box (IE盒模型)</p></blockquote><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>BFC 称为块级格式化上下文，是一块独立的区域，使BFC内部的元素与外部的元素分隔开来。<br>一开始是为了兼容CSS1.0中发明的P标签的样式，P标签跟P标签之间的margin上下距离都是一致，呈现美观。所以在2.0里面放入了BFC，即兼容了CSS1的设计，也比较符合设计师的设计。</p><p><code>能够产生BFC的条件：</code></p><blockquote><p>根元素<br>浮动元素（不为none的时候）<br>定位元素（absolute || fixed）<br>行内块元素（display：inline-block）<br>表格单元格（display：table-cell）<br>表格标题（display: table-caption）<br>匿名表格单元格元素<br>overflow（不为visible）<br>display(不是flow-root)<br>弹性元素<br>网格元素<br>多列容器</p></blockquote><p><code>BFC解决的一些事情</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">实现自定义的两栏布局<br>解决了浮动以后，父元素高度塌陷情况<br><span class="hljs-attribute">margin</span>的重叠<br></code></pre></td></tr></table></figure><h4 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h4><ol><li><p>水平居中布局</p><blockquote><p>行内元素：设置text-align: center<br>块状元素：</p><ul><li>margin：0 auto；</li><li>position: absolute + trnsform: translateX()</li><li>dispay: flex + justify-content: center</li></ul></blockquote></li><li><p>垂直居中布局</p><blockquote><p>行内元素：设置line-height：；<br>块状原色：</p><ul><li>position: absolute + transform: translateY()</li><li>display: flex + align-items: center</li></ul></blockquote></li><li><p>水平垂直居中布局</p><blockquote><p>position: absolute + transform: translate3d() // 可以在设置的同时，开启硬件加速<br>display: flex + justify-content: center + align-items: center</p></blockquote></li></ol><h4 id="display-none-跟visibility-hidden-的区别是什么？"><a href="#display-none-跟visibility-hidden-的区别是什么？" class="headerlink" title="display:none;跟visibility:hidden;的区别是什么？"></a>display:none;跟visibility:hidden;的区别是什么？</h4><ol><li><code>display:none;</code>: 隐藏元素，在布局中不会给其元素分配位置空间，会被当成不存在。</li><li><code>visibility:hidden;</code>: 隐藏元素，但是在布局存在，只是视觉上看不到而已。</li></ol><h4 id="Link跟-import的区别"><a href="#Link跟-import的区别" class="headerlink" title="Link跟@import的区别"></a>Link跟@import的区别</h4><blockquote><ol><li>link是html上的标签，而@import是css中的。</li><li>页面加载的时候，link标签会被同时加载出来，而@import是需要在页面加载完以后，才会被加载渲染。</li><li>link的样式权重高于@import的样式权重</li><li>link在浏览器中没有兼容性问题，而@import只能在IE5以上的浏览器中使用。</li></ol></blockquote><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h4 id="谈谈设计模式"><a href="#谈谈设计模式" class="headerlink" title="谈谈设计模式"></a>谈谈设计模式</h4><h4 id="防抖跟节流"><a href="#防抖跟节流" class="headerlink" title="防抖跟节流"></a>防抖跟节流</h4><ol><li>防抖：<blockquote><p>思路：如果在短时间内大量的触发同一个事件操作，就重新计时。比如说，设置时间空隙为2s，用户点击了操作以后，在2s以后会触发时间，如果在2s以内不停的触发，就会重新计算时间，等用户停止操作以后的2s内才会执行操作。</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 延时执行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-built_in">setTimeout</span>(fn, delay);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以立即执行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">1000</span>, immediate = <span class="hljs-literal">true</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">if</span> (!timer) fn.apply(_that);<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                timer = <span class="hljs-literal">null</span>;<br>            &#125;, delay);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                fn.apply(_that);<br>            &#125;, delay)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>节流：<blockquote><p>思路：如果短时间内大量的触发同一件事情的操作，在指定时间内，不管触发了几次，都只工作一次。</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        valid = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn();<br>            valid = <span class="hljs-literal">true</span>;<br>        &#125;, delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="REACT"><a href="#REACT" class="headerlink" title="REACT"></a>REACT</h3><h4 id="什么是react？"><a href="#什么是react？" class="headerlink" title="什么是react？"></a>什么是react？</h4><p>react是一个用于构建用户界面的javascript库，主要关注MVC中的VIEW层面。</p><h4 id="为什么使用react？"><a href="#为什么使用react？" class="headerlink" title="为什么使用react？"></a>为什么使用react？</h4><ul><li>使用VDOM而不是真实的DOM</li><li>可以用服务端渲染</li><li>遵循单向数据流或者数据绑定</li></ul><h4 id="react的优点跟缺点"><a href="#react的优点跟缺点" class="headerlink" title="react的优点跟缺点"></a>react的优点跟缺点</h4><p>优点：</p><ul><li><p>提高应用的性能</p></li><li><p>能够在客户端跟服务端使用</p></li><li><p>使用JSX，代码可读性更高</p></li><li><p>灵活：能与其他的库跟框架集成配合</p></li><li><p>组件化</p><p>缺点：</p></li><li><p>只是一个库，不是完整的框架</p></li><li><p>库很庞大需要时间理解</p></li><li><p>对于新手不是很友好</p></li><li><p>编程时会使用到内联模块个JSX，造成编码复杂</p></li></ul><h4 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h4><p>JSX是JavaScript Xml的简写，是JS内定义的一套XML语法，目前要使用Babel才能解析编译JSX，而Babel转换JSX以后其实就是React中的React.createElement的调用。而使用JSX的理由能让开发人员使用类HTML的标签创建虚拟DOM进行布局，即提高了开发效率，也减低了学习成本。</p><h4 id="什么时候使用状态管理器？"><a href="#什么时候使用状态管理器？" class="headerlink" title="什么时候使用状态管理器？"></a>什么时候使用状态管理器？</h4><p>我们都知道react只是DOM的一个抽象层，并不是整个web的解决方案。如果你的UI层非常的简单，而且没有太多的互动，你完全不需要用到状态管理，否则会让你的代码变得复杂。<br>但是如果你的项目中有大量的交互跟多数据源的话：</p><ul><li>用户的使用方式复杂</li><li>多个用户身份，多个使用方式</li><li>多个用户之间可以协作</li><li>与服务器大量的进行交互</li><li>View要从多个来源获取数据<br>组件层面来看：</li><li>某个组件的状态需要被共享</li><li>某个组件的信息要在任何地方可以拿到</li><li>一个组件能够改变全局的状态</li><li>一个组件能够改变另一个没关系的组件的状态</li></ul><h4 id="render函数中return如果没有使用-会有什么问题？"><a href="#render函数中return如果没有使用-会有什么问题？" class="headerlink" title="render函数中return如果没有使用()会有什么问题？"></a>render函数中return如果没有使用()会有什么问题？</h4><ul><li><p>当return带着返回具体的信息，比如<code>&lt;div&gt;我是信息&lt;/div&gt;</code>，是紧跟着return后面的，不加上括号也是没问题的，如图所示:<br><img src="/img/react1/img_khao1.png" alt="return不加括号的结果图1"></p></li><li><p>当return不紧随其后带着具体的信息，信息在return的下一行开始，如果不加上括号，就会报错，如图所示:<br><img src="/img/react1/img_khao2.png" alt="return不加括号的结果图2"></p></li><li><p>当return null的时候，只要是如1一样紧跟其后，不加括号也没有关系，如图所示：<br><img src="/img/react1/img_khao3.png" alt="return不加括号的结果图3"><br>同理可得，如果要换行写null，就会出现类似图二的错误</p></li><li><p>当return后面没有任何值，当然包括没有null时，不管有没有带括号，都会报错，如下图：<br><img src="/img/react1/img_khao4.png" alt="return不加括号的结果图4"><br><img src="/img/react1/img_khao5.png" alt="return不加括号的结果图5"></p></li></ul><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>setState是React中用来修改状态，更新视图的方式。</p><blockquote><ul><li>异步与同步：<br>我们都知道在React的实际开发中，在合成事件与生命周期钩子中，setState是”异步”的，我们无法在setState后直接获取state的更新数据，但是也不是说没有办法获取，可以通过setState(updateObj, callback)，通过callback回调函数进行获取最新的值。</li></ul><p>但是为什么会出现”异步”的情况呢，这里我们就要讲到React中的一个调用结构，就是事务。通过事务，可以统一的管理一个方法的开始跟结束。</p><ul><li>生命周期钩子：在生命周期中，我们能够看到更新策略的处于更新钩子之前，组件是处于事务流中，而在更新之后，组件就不在事务流中，因此会同步进行。</li><li>合成事件：React是基于<strong>事务流完成事件委托机制</strong>完成的，因此也是处于事务流中。</li></ul><p>通过上面的结论我们可以得出，只要不是处于事务流中的setState，就是同步的，在设置以后能够立刻获取新值，那么在哪些事件中是同步呢？</p><ul><li>原生事件：原生事件是浏览器本身的实现，与事务流无关。</li><li>setTimeout：放置于定时器中，就相当于位于定时器的线程中，会在其他的线程完成以后，开始进行的，因此事务流已经结束了，也呈现为同步。</li></ul></blockquote><p><code>注意：在我们实际开发中，同样会发现，多次连续调用setState，最后只会执行最后一次的setState。这是因为setState的合并，在合成事件中跟生命周期钩子中，多个连续的调用会被优化成一次。还有，当组件被销毁，还调用setState，React会报错。</code></p><h4 id="HOC（高阶组件）"><a href="#HOC（高阶组件）" class="headerlink" title="HOC（高阶组件）"></a>HOC（高阶组件）</h4>]]></content>
    
    
    
    <tags>
      
      <tag>HTML、CSS、JS、ES6、REACT、VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的世界</title>
    <link href="/2021/02/18/hello-hexo/"/>
    <url>/2021/02/18/hello-hexo/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><hr><p>其实博主是从2015年底就开始接触hexo了，但是因为当时并没有写博客的习惯，也没有记录任何信息的爱好，所有的尝试都被自己当成一次尝试就这么过去了。转眼间就到了2018年了，想着自己一事无成的博客之路，也是挺不好意思的，就把本文当成了一个真正的开始。这个努力，但是最后却以丢失hexo本地文件而最终破产！唉，索性博主跟小强一样，越挫越勇，还是打算重新来过，而这款hexo对于还没有自己服务器的小伙伴们，是比较友好的毕竟可以直接部署到github上面，如果说已经有自己服务器的同学，我还是比较建议自己动手搭建一个从零开始的自己的博客网站，毕竟作为前端的同学们，我们的vue、react、angular三大框架还是很有意思的，后端我们也是可以直接接触node，express不错！虽然目前来说有点小过时，但是对于学习技术，还是可以的。那么接下来我们还是正文开始~<br>let’s go~</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><hr><p>我们在开始hexo的搭建之前，首先我们需要先分别到git跟node官网下载下来我们需要用到的git跟node。</p><p><code>我们在开始hexo的搭建之前，首先我们需要先分别到git跟node官网下载下来我们需要用到的git跟node。</code></p><h4 id="下载hexo-cli"><a href="#下载hexo-cli" class="headerlink" title="下载hexo-cli"></a>下载hexo-cli</h4><blockquote><p>npm i -g hexo-cli</p></blockquote><p>检查hexo是否下载好,如果有下列信息就说明已经有了</p><blockquote><p><code>hexo -v</code><br><img src="/img/hexo_init_v.png" alt="hexo 版本信息"></p></blockquote><p>构建hexo文件,安装依赖</p><blockquote><p>hexo init <folder><br>cd <folder><br>npm install<br><code>在这里还是要首先说明一下，如果想生成新的文件夹，可以用hexo new “My New Post”,当然看你自己的习惯，我比较建议新人可以用命令熟悉。</code></p></blockquote><p>修改hexo文件配置信息</p><blockquote><p>hexo文件中的配置皆放在_config.yml文件中，一般我们需要更改的就是：</p><ul><li>title: BlackLike （主标题）</li><li>subtitle: BlackLike’s blog （副标题）</li><li>description: This is BlackLike’s Blog, welcome to everybody. （描述信息）</li><li>author: BlackLike （作者即博主）</li></ul><p><em>以上几个为基本配置，后面还需要修改相应的配置，暂时不在此处指出，我们一步一步来</em></p></blockquote><p>本地运行</p><blockquote><p>当我们的基本配置已经完成以后，我们可能是需要先在本地查看一下效果，那么就需要我们运行一下<br><code>hexo server</code> or <code>hexo s</code></p></blockquote><h4 id="部署上github"><a href="#部署上github" class="headerlink" title="部署上github"></a>部署上github</h4><blockquote><p>本地查看了信息，感觉已经很不错了，那么我们就可以先把目前版本信息上传至github中的个人仓库中，在这里我们需要一下几步操作</p><ol><li>首先我们需要回到_config.yml文件中去，修改deploy：下面的信息，一般我们只要写：</li></ol><ul><li>type: git</li><li>repo: （远程仓库）<code>这里要注意，你的远程仓库的名称要跟你的用户名一致，比方我的是blacklike，我的仓库就是blacklike。github.io</code></li><li>branch：（分支名，一般都是master）</li></ul><ol start="2"><li>修改以后，我们需要先配置ssh，这个步骤我就不讲了，网络上有很多的博客是能写到的，所以如果配置好了ssh可以直接跳过这一步，如果没有配置的，应该是不想配置ssh的同学，请配置你的全局的git信息：</li></ol><ul><li>git config –golbal user.email “<a href="mailto:&#121;&#x6f;&#x75;&#64;&#121;&#111;&#117;&#46;&#x63;&#x6f;&#x6d;">&#121;&#x6f;&#x75;&#64;&#121;&#111;&#117;&#46;&#x63;&#x6f;&#x6d;</a>“</li><li>git config –golbal user.name “youname”</li></ul><ol start="3"><li>hexo generate (可以简写为hexo g)</li><li>hexo deploy (可以简写为 hexo d)<br>注意如果第四步出现了<code>ERROR Deployer not found: git</code>,说明你还没有为hexo安装git插件，需要运行<code>npm i hexo-deployer-git --save</code>进行安装。然后再执行第四部，然后就到你的github上面看看你的文件信息是否部署好。需要注意的是，因为hexo是部署上去的，而不是push上去的，所以只会把public里面的信息部署到上面，所以千万不要删除你本地的hexo文件，因为删除了就没有了，你如果想在git上面单独存储，可以开个仓库，单独存放。</li></ol></blockquote><h4 id="github上的配置"><a href="#github上的配置" class="headerlink" title="github上的配置"></a>github上的配置</h4><blockquote><p>文件部署完成以后，我们能看到仓库页面有个settings<br><img src="/img/setting_menu.jpg" alt="github 导航栏"><br>点击进去，设置你博客进入的入口地址<br><img src="/img/github_setting_url.jpg" alt="setting 页面"><br>这样就可以根据绿色条进入到你的博客地址当中去了！</p></blockquote><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><code>地址打开发现css等样式都是没有的，为什么呢？</code></li></ol><p>很多小伙伴可能在部署到github上以后打开生成好的url的时候，发现页面当中样式都是没有的，可能很疑惑，当然不需要太惊慌，可能是你的配置还没有把路径配置好<br>这时候，我们可以回到_config.yml当中，找到以下几个属性：<br>    - url: 你的url地址<br>    - root: 你的文件名，如果你没有另开文件夹，这里可以只设置-&gt; /</p><p>设置好以后，重新部署一下，就完美了，可以玩耍了~</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>以上都是从零开始搭建到上传github的过程，接下来说点其他的，hexo会存在默认的主题，或许很多小伙伴都不想跟人一样，想有点自己的主题特色，那就试试，hexo的主题设置吧~</p><blockquote><p>首先，你先进入到<a href="https://hexo.io/themes/">Hexo的主题专线</a><br>然后选择你想要的喜欢的Hexo的主题<br>点击进去，一般来说都能进入到该主题的github的页面，根据作者的文档进行主题的下载跟设置</p></blockquote><h3 id="写在最后的温馨提示"><a href="#写在最后的温馨提示" class="headerlink" title="写在最后的温馨提示"></a>写在最后的温馨提示</h3><p>由于本人血的教训，已经不下几次重新创建这个hexo博客了，最头疼的就是将本地的hexo推到远程以后，远程创建的只是一个hexo编译好的架构，一旦本地的hexo文件丢失，即使把远程的文件拉下来也没有用，依旧要重新init搭建一个hexo，没有任何方式找回丢失删除的hexo本地文件，这是血的教训，请使用hexo的各位小伙伴切记，你通过hexo命令推送了一版编译好的hexo博客的同时，请做好本地hexo文件的备份跟储存，非常重要！！！！切记！！！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
