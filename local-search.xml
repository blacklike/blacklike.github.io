<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>typeScript的学习笔记1</title>
    <link href="/2021/03/05/typeScript01/"/>
    <url>/2021/03/05/typeScript01/</url>
    
    <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Boolean: true / false</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isBoolean: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>ts中的数字跟js一样，都是浮点数，类型为number，二进制、十进制、十六进制等等</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>文本语言，类型是string，可以用””双引号，也可以用’’单引号表示</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> str1: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;test1&#x27;</span>;<br><span class="hljs-keyword">let</span> str2: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;test2&quot;</span><br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>类型array，ts中表达的方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">let</span> arr1: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">let</span> arr2: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">let</span> arr3: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>表示一个已知元素类型跟数量的数组，如果赋值跟定义的不一样就会报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> arr: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>] = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>类型：enum，枚举提供给开发人员一个便利，就是在知道数值的情况下，通过数值去查询数值对应的名称</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green = <span class="hljs-number">2</span>, Blue&#125;<br><span class="hljs-keyword">let</span> colorName: <span class="hljs-built_in">string</span> = Color[<span class="hljs-number">2</span>]; <span class="hljs-comment">// Green</span><br></code></pre></td></tr></table></figure><h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>表示任意类型，在开发的时候，如果无法事先得知参数的类型，可以赋予Any</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> anyTest: <span class="hljs-built_in">any</span> = <span class="hljs-literal">true</span>;<br>anyTest = <span class="hljs-number">1</span>;<br>anyTest = <span class="hljs-string">&#x27;test&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object类型表示除了number、string、boolean、symbol、null或者undefined之外的类型</p><h3 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h3><p>表示没有类型，从某种角度来说，它跟any相反。如果要声明一个void类型，我们只能给它赋值null或者undefinde，而对于函数来说，没有返回的时候就是void</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-built_in">this</span>.a: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> a: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><blockquote><p>某种说法下，类型的设置跟null还有undefined其实差不多</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">let</span> b: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>表示预知的下一个实体具有比它现在类型更确切的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> b: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a duanyan&quot;</span>;<br><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">let</span> len: <span class="hljs-built_in">number</span> = (b <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).length;<br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">let</span> len: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;b).length;<br></code></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ol><li>通过var</li><li>通过let</li><li>通过const<blockquote><p>这里需要注意var有变量声明提升，let跟const是有块级作用域，而const赋值以后无法更改。</p></blockquote></li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>用于做定义，来描述结构，关键字是：interface</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> labelObj &#123;<br>    label: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LabelFn</span> (<span class="hljs-params">labelObject: labelObj</span>) : (<span class="hljs-params">a: <span class="hljs-built_in">string</span>, b: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        a: labelObject.label,<br>        b: <span class="hljs-number">20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>属性的只读设置：readonly x: string<br>数组的只读设置：ReadonlyArray<number> = [1,2,3,4]</p><blockquote><p>只读的信息是无法更改的，只能读取</p></blockquote><h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>在js中，当遇到传入参数，不在定义的参数之中，对于程序来说不会报错，只会当成一个额外的参数传入而已。<br>但是在ts中会认为这个是一个bug，然后抛出异常。当这个值作为变量或者参数传递的时候，存在了不包含的参数，就是一个错误。</p><p>而解决这种错误的方法就是要绕过检查：</p><ol><li>利用断言的方式<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> test &#123;<br>    width: <span class="hljs-built_in">number</span>;<br>    height: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">&#123;width: <span class="hljs-number">20</span>, color: <span class="hljs-string">&#x27;red&#x27;</span>&#125; <span class="hljs-keyword">as</span> test</span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>使用字符串索引签名: 可以往里面添加任意的索引<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> test &#123;<br>    width: <span class="hljs-built_in">number</span>;<br>    height: <span class="hljs-built_in">number</span>;<br>    [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3>接口类型也可以定义函数，直接代替函数中的参数跟返回值<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> fn &#123;<br>    (name: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> myFn: fn;<br>myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) : <span class="hljs-title">boolean</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> age &gt; <span class="hljs-number">18</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>定义数组的接口，可定义string类型的索引，也可以定义number类型的索引</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> testArr &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> testObj &#123;<br>    [objInx: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">let</span> arr: testArr = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]<br><span class="hljs-keyword">let</span> obj: testObj = &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>可以用接口去约定类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> classInterface &#123;<br>    currentTime: <span class="hljs-built_in">Date</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-title">implements</span> <span class="hljs-title">classInterface</span> </span>&#123;<br>    currentTime: <span class="hljs-built_in">Date</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">h: <span class="hljs-built_in">number</span>, m: <span class="hljs-built_in">number</span></span>)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端知识点的杂记</title>
    <link href="/2021/02/18/react1/"/>
    <url>/2021/02/18/react1/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h4 id="doctype-文档类型-的作用是什么？？？"><a href="#doctype-文档类型-的作用是什么？？？" class="headerlink" title="doctype(文档类型)的作用是什么？？？"></a>doctype(文档类型)的作用是什么？？？</h4><p>用于声明文档类型和DTD规范，确保不同的浏览器能够用相同的是方法解析文档，并且执行相同的渲染模式。<br>DTD：文档类型定义，是XML的文档类型定于，是XML的约束。</p><h4 id="浏览器标准模式-standards-mode-、接近标准模式（almost-standards-mode）和怪异模式-quirks-mode-之间的区别是什么？"><a href="#浏览器标准模式-standards-mode-、接近标准模式（almost-standards-mode）和怪异模式-quirks-mode-之间的区别是什么？" class="headerlink" title="浏览器标准模式 (standards mode) 、接近标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？"></a>浏览器标准模式 (standards mode) 、接近标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？</h4><p>怪异模式：向后兼容，因为老的浏览器是没有很多的规范，但随着浏览器的发展，制定了越来越多的规范。所以为了兼容这样的老是浏览器，才有了怪异模式。<br>接近标准模式：几乎跟标准模式差不多，但是还是有些差别，比方对于表格单元格中设置图像会去掉下面的空隙。标准的单元格内设置图像，由于图像会以文字的基线为准，比如想g，j这样要显示下面，就会产生空隙。<br>标准模式：以最高的标准渲染。</p><h4 id="HTML和XHTML有什么区别？"><a href="#HTML和XHTML有什么区别？" class="headerlink" title="HTML和XHTML有什么区别？"></a>HTML和XHTML有什么区别？</h4><ol><li>XHTML有大小写区分，比如&lt;DIV&gt;跟&lt;div&gt;是两个东西</li><li>XHTML有良好的文档结构，需要合理的嵌套。比如&lt;p&gt;&lt;span&gt;&lt;/p&gt;&lt;/span&gt;这种是有问题的。</li><li>XHTML必须要有结束标签，即使是空标签也必须要有&lt;/&gt;，否则会报错。</li><li>XHTML必须拥有一个根标签，就是必须嵌套在&lt;html&gt;根元素中。</li><li>XHTML中的属性必须使用引号，否则会报错。</li><li>HTML中用脚本读取HTML标签或者属性的时候，返回的是大写；但是XHTML返回的是小写。</li></ol><h4 id="如果页面使用’application-xhtml-xml’会有什么问题吗？"><a href="#如果页面使用’application-xhtml-xml’会有什么问题吗？" class="headerlink" title="如果页面使用’application/xhtml+xml’会有什么问题吗？"></a>如果页面使用’application/xhtml+xml’会有什么问题吗？</h4><p>如果使用了XHTML，页面结构中的所有的标签都必须关闭，包括空标签。而且”application/xhtml+xml”在部分老的浏览器中不支持。</p><h4 id="响应式设计是什么？响应式原理是什么？"><a href="#响应式设计是什么？响应式原理是什么？" class="headerlink" title="响应式设计是什么？响应式原理是什么？"></a>响应式设计是什么？响应式原理是什么？</h4><p>响应式：同一个页面展示在不同的浏览器分辨率或者尺寸下有不同的页面结构跟表现，但是是用同一套代码。</p><p>方式：媒体查询、rem</p><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><blockquote><p>目前主流的盒模型分为两类：</p><ol><li>W3C标准盒模型：content + padding + border + margin</li><li>IE盒模型: content(content + padding + border) + margin</li></ol><p>盒模型是可以通过box-sizing设置：<br>content-box (W3C标准盒模型)<br>border-box (IE盒模型)</p></blockquote><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>BFC 称为块级格式化上下文，是一块独立的区域，使BFC内部的元素与外部的元素分隔开来。<br>一开始是为了兼容CSS1.0中发明的P标签的样式，P标签跟P标签之间的margin上下距离都是一致，呈现美观。所以在2.0里面放入了BFC，即兼容了CSS1的设计，也比较符合设计师的设计。</p><p><code>能够产生BFC的条件：</code></p><blockquote><p>根元素<br>浮动元素（不为none的时候）<br>定位元素（absolute || fixed）<br>行内块元素（display：inline-block）<br>表格单元格（display：table-cell）<br>表格标题（display: table-caption）<br>匿名表格单元格元素<br>overflow（不为visible）<br>display(不是flow-root)<br>弹性元素<br>网格元素<br>多列容器</p></blockquote><p><code>BFC解决的一些事情</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">实现自定义的两栏布局<br>解决了浮动以后，父元素高度塌陷情况<br><span class="hljs-attribute">margin</span>的重叠<br></code></pre></td></tr></table></figure><h4 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h4><ol><li><p>水平居中布局</p><blockquote><p>行内元素：设置text-align: center<br>块状元素：</p><ul><li>margin：0 auto；</li><li>position: absolute + trnsform: translateX()</li><li>dispay: flex + justify-content: center</li></ul></blockquote></li><li><p>垂直居中布局</p><blockquote><p>行内元素：设置line-height：；<br>块状原色：</p><ul><li>position: absolute + transform: translateY()</li><li>display: flex + align-items: center</li></ul></blockquote></li><li><p>水平垂直居中布局</p><blockquote><p>position: absolute + transform: translate3d() // 可以在设置的同时，开启硬件加速<br>display: flex + justify-content: center + align-items: center</p></blockquote></li></ol><h4 id="display-none-跟visibility-hidden-的区别是什么？"><a href="#display-none-跟visibility-hidden-的区别是什么？" class="headerlink" title="display:none;跟visibility:hidden;的区别是什么？"></a>display:none;跟visibility:hidden;的区别是什么？</h4><ol><li><code>display:none;</code>: 隐藏元素，在布局中不会给其元素分配位置空间，会被当成不存在。</li><li><code>visibility:hidden;</code>: 隐藏元素，但是在布局存在，只是视觉上看不到而已。</li></ol><h4 id="Link跟-import的区别"><a href="#Link跟-import的区别" class="headerlink" title="Link跟@import的区别"></a>Link跟@import的区别</h4><blockquote><ol><li>link是html上的标签，而@import是css中的。</li><li>页面加载的时候，link标签会被同时加载出来，而@import是需要在页面加载完以后，才会被加载渲染。</li><li>link的样式权重高于@import的样式权重</li><li>link在浏览器中没有兼容性问题，而@import只能在IE5以上的浏览器中使用。</li></ol></blockquote><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h4 id="谈谈设计模式"><a href="#谈谈设计模式" class="headerlink" title="谈谈设计模式"></a>谈谈设计模式</h4><h4 id="var、let、const的区别是什么？"><a href="#var、let、const的区别是什么？" class="headerlink" title="var、let、const的区别是什么？"></a>var、let、const的区别是什么？</h4><blockquote><ul><li><code>var</code>是ES5的定义，而<code>let</code>、<code>const</code>是ES6提出的.</li><li><code>var</code>存在变量提升，而<code>let</code>、<code>const</code>不存在变量提升.</li><li><code>var</code>声明的变量，要么在全局作用域中，要么在局部作用域中。而<code>let</code>声明的变量只在块级作用域中有效。</li><li><code>let</code>、<code>const</code>声明变量之前就使用变量会报错，形成一个“暂时性死区”.</li><li><code>var</code>声明变量是可以重复声明，但是<code>let</code>、<code>const</code>声明过以后不允许重复声明.</li><li><code>var</code>声明的变量会被添加到window对象上，但是<code>let</code>、<code>const</code>声明的变量是不会被添加到windows对象上的。</li><li><code>var</code>跟<code>let</code>声明的变量的值都是可以更改的，但是<code>const</code>声明变量以后必须立刻初始化，赋初始值。因为一旦声明不对其初始化赋值，会报错。<br><code>const</code>赋值以后，无法进行更改。如果const的值是基本类型，如number，string等，无法修改值。但是如果是obj这种指向地址，而非地址里面的值，是可以更改地址里面的值，但是如果更改指向地址，会报错。</li></ul></blockquote><h4 id="promise-原理"><a href="#promise-原理" class="headerlink" title="promise 原理"></a>promise 原理</h4><h4 id="GET-跟-POST的区别"><a href="#GET-跟-POST的区别" class="headerlink" title="GET 跟 POST的区别"></a>GET 跟 POST的区别</h4><p>GET：</p><ul><li>一般用于信息的获取，使用URL传递参数，对所发送的信息数量也有限制，一般在2000个字符。</li></ul><p>POST：</p><ul><li>一般用于修改服务器上的资源，通过提交的表单传递值，对所发送的信息没有限制。</li></ul><h4 id="前端存储-cookie-sessionStorage-localStorage-的区别"><a href="#前端存储-cookie-sessionStorage-localStorage-的区别" class="headerlink" title="前端存储 cookie || sessionStorage || localStorage 的区别"></a>前端存储 cookie || sessionStorage || localStorage 的区别</h4><p>cookie：<br>严格来讲cokkie是跟后端有关系的，作用于服务端交互。但是cookie有大小的限制，以及个数的限制，大小不得超过4k，个数有的是20个有的是50个。有缓存时间限制，超过了缓存时间，就会被清楚掉。在HTTP请求的时候，会将cookie信息自动发送给后端。</p><p>sessionStorage:<br>本地存储的方式之一，是一种会话存储，生命周期是会话框的时间，一旦会话框被关闭，存储的信息也就被清除了。</p><p>localStorage:<br>本地存储，大小有5M，存储的数据只要不手动清除是不会消失一直存在于本地。</p><h4 id="请解释-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。"><a href="#请解释-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别。" class="headerlink" title="请解释 &lt;script&gt;、&lt;script async&gt; 和 &lt;script defer&gt; 的区别。"></a>请解释 &lt;script&gt;、&lt;script async&gt; 和 &lt;script defer&gt; 的区别。</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>// 在不添加任何属性的时候,浏览器只要读到就会立即加载以及执行，不会等待后续文档加载，因此可能会阻塞文档读取。<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>// async是会异步加载以及执行，只要加载完毕，就会立刻执行。<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>// defer跟async在加载上一样，都是异步执行的，但是不会跟async一样加载完毕就执行，它会等到后续文档都加载完毕了，再执行。因此defer会比较符合我们日常开发的需求。<br></code></pre></td></tr></table></figure><h4 id="什么是渐进式渲染-progressive-rendering-？"><a href="#什么是渐进式渲染-progressive-rendering-？" class="headerlink" title="什么是渐进式渲染 (progressive rendering)？"></a>什么是渐进式渲染 (progressive rendering)？</h4><p>渐进式渲染是为了提高网页的优化，是一种尽快呈现页面的技术。比如图片懒加载，比如分层次渲染。</p><h4 id="防抖跟节流"><a href="#防抖跟节流" class="headerlink" title="防抖跟节流"></a>防抖跟节流</h4><ol><li>防抖：<blockquote><p>思路：如果在短时间内大量的触发同一个事件操作，就重新计时。比如说，设置时间空隙为2s，用户点击了操作以后，在2s以后会触发时间，如果在2s以内不停的触发，就会重新计算时间，等用户停止操作以后的2s内才会执行操作。</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 延时执行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>        timer = <span class="hljs-built_in">setTimeout</span>(fn, delay);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以立即执行</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">1000</span>, immediate = <span class="hljs-literal">true</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-keyword">if</span> (immediate) &#123;<br>            <span class="hljs-keyword">if</span> (!timer) fn.apply(_that);<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                timer = <span class="hljs-literal">null</span>;<br>            &#125;, delay);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                fn.apply(_that);<br>            &#125;, delay)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>节流：<blockquote><p>思路：如果短时间内大量的触发同一件事情的操作，在指定时间内，不管触发了几次，都只工作一次。</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> valid = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!valid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        valid = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn();<br>            valid = <span class="hljs-literal">true</span>;<br>        &#125;, delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HTTP跟HTTPS的区别"><a href="#HTTP跟HTTPS的区别" class="headerlink" title="HTTP跟HTTPS的区别"></a>HTTP跟HTTPS的区别</h4><ol><li>HTTPS需要CA证书，费用会比较昂贵</li><li>HTTP是超文本协议传输，信息是明文的。HTTPS是安全的SSL加密协议传输。</li><li>HTTP的端口是80，HTTPS的端口是443。</li><li>HTTP连接简单，是无状态的。HTTPS是由SSL+HTTP协议构建的可加密传输、身份认证的网络协议，比HTTP安全。</li></ol><h4 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h4><ol><li>客户端使用HTTPS url访问服务端，请求跟服务端建立SSL传输连接。</li><li>服务端接收到客户端的请求，会将网站的证书（证书中包含公钥），返回给客户端。</li><li>客户端会跟服务端开始协商SSL的安全等级</li><li>客户端跟服务端统一了安全等级以后，会建立一个会话秘钥，然后通过网站的公钥来加密会话的秘钥，并且传递网站。</li><li>服务端会通过自己的私钥来解密会话的秘钥。</li><li>服务端会通过会话秘钥来加密跟客户端之间的通信。</li></ol><h4 id="浏览器从输入URL到打开页面发生了什么？"><a href="#浏览器从输入URL到打开页面发生了什么？" class="headerlink" title="浏览器从输入URL到打开页面发生了什么？"></a>浏览器从输入URL到打开页面发生了什么？</h4><blockquote><ol><li>浏览器输入URL</li><li>浏览器查询缓存是否为最新的，是，就展示缓存信息，否就看下一步。</li><li>解析URL获取协议，端口，域名以及PATH</li><li>组装一个HTTP（GET）请求报文</li><li>获取主机IP</li></ol><ul><li>浏览器缓存</li><li>本地缓存</li><li>Hosts文件</li><li>DNS</li><li>路由器缓存</li></ul><ol start="6"><li>打开soket与目标IP、端口进行TCP连接</li><li>连接成功以后，发送HTTP请求</li><li>服务端接受并且解析该请求，并且发送给服务程序</li><li>服务程序查看缓存，如果有，直接返回304</li><li>处理程序要读取完整的请求并准备HTTP响应</li><li>服务器将响应报文通过TCP连接返回</li><li>接受到HTTP响应，就可以选择关闭TCP连接</li><li>检查响应码</li><li>将响应资源缓存</li><li>将响应进行解码</li><li>然后解析HTML文件，构建DOM树，CSS树，执行JS脚本</li><li>渲染页面</li></ol></blockquote><h4 id="TCP的三次握手跟四次挥手"><a href="#TCP的三次握手跟四次挥手" class="headerlink" title="TCP的三次握手跟四次挥手"></a>TCP的三次握手跟四次挥手</h4><p>客户端跟服务端之间的连接，是通过TPC协议<br><code>握手</code>：</p><blockquote><ul><li>客户端发送SYN（同步序列编号）包到服务器，进入到SYN_SENT状态中，等待服务端确认</li><li>服务端接收到SYN包，必须先确认客户端发来的SYN包，同时自己也发送一个SYN+ACK包，进入到SYN_RECV状态</li><li>客户端接收到服务端的SYN+ACK包，向服务端发送确认包ACK，客户端跟服务端进入TCP连接成功状态，完成三次握手</li></ul></blockquote><p><code>挥手</code>:</p><blockquote><ul><li>客户端发送释放报文，并且停止发送数据，发送FIN</li><li>服务端端接收到释放报文，发出确认报文</li><li>客户端接收到服务端的确认请求以后，进入到了关闭等待中</li><li>服务端最后数据发完以后，向客户端发送释放报文，等待客户端确认</li><li>客户端收到服务端发送的释放报文，必须发出确认，然后服务端收到确认信息以后，TCP关闭连接。</li></ul></blockquote><h4 id="强制缓存跟协商缓存"><a href="#强制缓存跟协商缓存" class="headerlink" title="强制缓存跟协商缓存"></a>强制缓存跟协商缓存</h4><p>浏览器向服务端发起请求的时候，首先会确认缓存信息，cache-control跟expores信息，如果命中缓存，就会直接走强制缓存，不会跟服务端进行通信，直接返回缓存信息。<br>如果没有命中强制缓存，浏览器会发送请求到服务端，请求中会携带last-modifued/etag等参数，如果命中了协商缓存，会返回304，告诉浏览器直接从缓存中取，如果没有，会直接返回新的响应内容。</p><h2 id="REACT"><a href="#REACT" class="headerlink" title="REACT"></a>REACT</h2><h4 id="什么是react？"><a href="#什么是react？" class="headerlink" title="什么是react？"></a>什么是react？</h4><p>react是一个用于构建用户界面的javascript库，主要关注MVC中的VIEW层面。</p><h4 id="为什么使用react？"><a href="#为什么使用react？" class="headerlink" title="为什么使用react？"></a>为什么使用react？</h4><ul><li>使用VDOM而不是真实的DOM</li><li>可以用服务端渲染</li><li>遵循单向数据流或者数据绑定</li></ul><h4 id="react的优点跟缺点"><a href="#react的优点跟缺点" class="headerlink" title="react的优点跟缺点"></a>react的优点跟缺点</h4><p>优点：</p><ul><li><p>提高应用的性能</p></li><li><p>能够在客户端跟服务端使用</p></li><li><p>使用JSX，代码可读性更高</p></li><li><p>灵活：能与其他的库跟框架集成配合</p></li><li><p>组件化</p><p>缺点：</p></li><li><p>只是一个库，不是完整的框架</p></li><li><p>库很庞大需要时间理解</p></li><li><p>对于新手不是很友好</p></li><li><p>编程时会使用到内联模块个JSX，造成编码复杂</p></li></ul><h4 id="什么是JSX？"><a href="#什么是JSX？" class="headerlink" title="什么是JSX？"></a>什么是JSX？</h4><p>JSX是JavaScript Xml的简写，是JS内定义的一套XML语法，目前要使用Babel才能解析编译JSX，而Babel转换JSX以后其实就是React中的React.createElement的调用。而使用JSX的理由能让开发人员使用类HTML的标签创建虚拟DOM进行布局，即提高了开发效率，也减低了学习成本。</p><h4 id="什么时候使用状态管理器？"><a href="#什么时候使用状态管理器？" class="headerlink" title="什么时候使用状态管理器？"></a>什么时候使用状态管理器？</h4><p>我们都知道react只是DOM的一个抽象层，并不是整个web的解决方案。如果你的UI层非常的简单，而且没有太多的互动，你完全不需要用到状态管理，否则会让你的代码变得复杂。<br>但是如果你的项目中有大量的交互跟多数据源的话：</p><ul><li>用户的使用方式复杂</li><li>多个用户身份，多个使用方式</li><li>多个用户之间可以协作</li><li>与服务器大量的进行交互</li><li>View要从多个来源获取数据<br>组件层面来看：</li><li>某个组件的状态需要被共享</li><li>某个组件的信息要在任何地方可以拿到</li><li>一个组件能够改变全局的状态</li><li>一个组件能够改变另一个没关系的组件的状态</li></ul><h4 id="render函数中return如果没有使用-会有什么问题？"><a href="#render函数中return如果没有使用-会有什么问题？" class="headerlink" title="render函数中return如果没有使用()会有什么问题？"></a>render函数中return如果没有使用()会有什么问题？</h4><ul><li><p>当return带着返回具体的信息，比如<code>&lt;div&gt;我是信息&lt;/div&gt;</code>，是紧跟着return后面的，不加上括号也是没问题的，如图所示:<br><img src="/img/react1/img_khao1.png" alt="return不加括号的结果图1"></p></li><li><p>当return不紧随其后带着具体的信息，信息在return的下一行开始，如果不加上括号，就会报错，如图所示:<br><img src="/img/react1/img_khao2.png" alt="return不加括号的结果图2"></p></li><li><p>当return null的时候，只要是如1一样紧跟其后，不加括号也没有关系，如图所示：<br><img src="/img/react1/img_khao3.png" alt="return不加括号的结果图3"><br>同理可得，如果要换行写null，就会出现类似图二的错误</p></li><li><p>当return后面没有任何值，当然包括没有null时，不管有没有带括号，都会报错，如下图：<br><img src="/img/react1/img_khao4.png" alt="return不加括号的结果图4"><br><img src="/img/react1/img_khao5.png" alt="return不加括号的结果图5"></p></li></ul><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>setState是React中用来修改状态，更新视图的方式。</p><blockquote><ul><li>异步与同步：<br>我们都知道在React的实际开发中，在合成事件与生命周期钩子中，setState是”异步”的，我们无法在setState后直接获取state的更新数据，但是也不是说没有办法获取，可以通过setState(updateObj, callback)，通过callback回调函数进行获取最新的值。</li></ul><p>但是为什么会出现”异步”的情况呢，这里我们就要讲到React中的一个调用结构，就是事务。通过事务，可以统一的管理一个方法的开始跟结束。</p><ul><li>生命周期钩子：在生命周期中，我们能够看到更新策略的处于更新钩子之前，组件是处于事务流中，而在更新之后，组件就不在事务流中，因此会同步进行。</li><li>合成事件：React是基于<strong>事务流完成事件委托机制</strong>完成的，因此也是处于事务流中。</li></ul><p>通过上面的结论我们可以得出，只要不是处于事务流中的setState，就是同步的，在设置以后能够立刻获取新值，那么在哪些事件中是同步呢？</p><ul><li>原生事件：原生事件是浏览器本身的实现，与事务流无关。</li><li>setTimeout：放置于定时器中，就相当于位于定时器的线程中，会在其他的线程完成以后，开始进行的，因此事务流已经结束了，也呈现为同步。</li></ul></blockquote><p><code>注意：在我们实际开发中，同样会发现，多次连续调用setState，最后只会执行最后一次的setState。这是因为setState的合并，在合成事件中跟生命周期钩子中，多个连续的调用会被优化成一次。还有，当组件被销毁，还调用setState，React会报错。</code></p><h4 id="HOC（高阶组件）"><a href="#HOC（高阶组件）" class="headerlink" title="HOC（高阶组件）"></a>HOC（高阶组件）</h4>]]></content>
    
    
    
    <tags>
      
      <tag>HTML、CSS、JS、ES6、REACT、VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React自上而下的学习笔记-----理论篇</title>
    <link href="/2021/01/15/react-learn/"/>
    <url>/2021/01/15/react-learn/</url>
    
    <content type="html"><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>官网提出的：</p><blockquote><p>React是用JavaScript构建<strong>快速响应</strong>的大型Web应用程序的首选方式。它在Facebook和Instagram上的表现优秀。</p></blockquote><p>由此可见，React打造的就是快速响应，但是在我们日常使用APP、浏览器的时候，会因为一些场景造成快速响应被制约：</p><ul><li>CPU的瓶颈：当遇到大计算量的操作或者设备性能不足导致页面掉帧卡顿。</li><li>IO(input/output)的瓶颈: 发送网络请求以后，由于需要等待数据的返回才能进行下一步的操作导致不能快速的响应。</li></ul><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>众所周知，主流浏览器刷新频率是60HZ，就是(1000ms / 60HZ) 就是16.6ms浏览器刷新一次。<br>但是，GUI渲染线程跟JS线程是互斥的，因此，JS脚本跟浏览器布局、绘制不能同时进行，而在每16.6ms内，需要完成：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">JS脚本执行<br>样式布局<br>样式绘制<br></code></pre></td></tr></table></figure><p>所以一旦JS执行时间过长，超出了16.6ms，那么这次的刷新就没有时间执行后面的程序了。</p><p>react为了解决这个问题，在浏览器每一帧的时间中，预留一些时间（预留的时间为5s）给JS线程，而React会利用这个时间更新组件，但是如果预留的时间不能执行完JS，react会把线程的控制权还给浏览器，让其有时间渲染UI，而React就等待下一帧的时间来继续被中断的工作，这个过程就被称为时间切片。</p><p>而React中要使用这个时间切片，就需要开启Concurrent Mode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs React">&#x2F;&#x2F; 通过使用ReactDOM.unstable_createRoot开启Concurrent Mode<br>ReactDOM.unstable_createRoot(rootEl).render(&lt;App &#x2F;&gt;);<br></code></pre></td></tr></table></figure><blockquote><p>所以综上所述，React解决CPU的短板问题，使用了时间切片，而时间切片的关键就是将同步的更新变成可以中断的异步更新。</p></blockquote><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的世界</title>
    <link href="/2021/01/01/hello-hexo/"/>
    <url>/2021/01/01/hello-hexo/</url>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><hr><p>其实博主是从2015年底就开始接触hexo了，但是因为当时并没有写博客的习惯，也没有记录任何信息的爱好，所有的尝试都被自己当成一次尝试就这么过去了。转眼间就到了2018年了，想着自己一事无成的博客之路，也是挺不好意思的，就把本文当成了一个真正的开始。这个努力，但是最后却以丢失hexo本地文件而最终破产！唉，索性博主跟小强一样，越挫越勇，还是打算重新来过，而这款hexo对于还没有自己服务器的小伙伴们，是比较友好的毕竟可以直接部署到github上面，如果说已经有自己服务器的同学，我还是比较建议自己动手搭建一个从零开始的自己的博客网站，毕竟作为前端的同学们，我们的vue、react、angular三大框架还是很有意思的，后端我们也是可以直接接触node，express不错！虽然目前来说有点小过时，但是对于学习技术，还是可以的。那么接下来我们还是正文开始~<br>let’s go~</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><hr><p>我们在开始hexo的搭建之前，首先我们需要先分别到git跟node官网下载下来我们需要用到的git跟node。</p><p><code>我们在开始hexo的搭建之前，首先我们需要先分别到git跟node官网下载下来我们需要用到的git跟node。</code></p><h4 id="下载hexo-cli"><a href="#下载hexo-cli" class="headerlink" title="下载hexo-cli"></a>下载hexo-cli</h4><blockquote><p>npm i -g hexo-cli</p></blockquote><p>检查hexo是否下载好,如果有下列信息就说明已经有了</p><blockquote><p><code>hexo -v</code><br><img src="/img/hexo_init_v.png" alt="hexo 版本信息"></p></blockquote><p>构建hexo文件,安装依赖</p><blockquote><p>hexo init <folder><br>cd <folder><br>npm install<br><code>在这里还是要首先说明一下，如果想生成新的文件夹，可以用hexo new “My New Post”,当然看你自己的习惯，我比较建议新人可以用命令熟悉。</code></p></blockquote><p>修改hexo文件配置信息</p><blockquote><p>hexo文件中的配置皆放在_config.yml文件中，一般我们需要更改的就是：</p><ul><li>title: BlackLike （主标题）</li><li>subtitle: BlackLike’s blog （副标题）</li><li>description: This is BlackLike’s Blog, welcome to everybody. （描述信息）</li><li>author: BlackLike （作者即博主）</li></ul><p><em>以上几个为基本配置，后面还需要修改相应的配置，暂时不在此处指出，我们一步一步来</em></p></blockquote><p>本地运行</p><blockquote><p>当我们的基本配置已经完成以后，我们可能是需要先在本地查看一下效果，那么就需要我们运行一下<br><code>hexo server</code> or <code>hexo s</code></p></blockquote><h4 id="部署上github"><a href="#部署上github" class="headerlink" title="部署上github"></a>部署上github</h4><blockquote><p>本地查看了信息，感觉已经很不错了，那么我们就可以先把目前版本信息上传至github中的个人仓库中，在这里我们需要一下几步操作</p><ol><li>首先我们需要回到_config.yml文件中去，修改deploy：下面的信息，一般我们只要写：</li></ol><ul><li>type: git</li><li>repo: （远程仓库）<code>这里要注意，你的远程仓库的名称要跟你的用户名一致，比方我的是blacklike，我的仓库就是blacklike。github.io</code></li><li>branch：（分支名，一般都是master）</li></ul><ol start="2"><li>修改以后，我们需要先配置ssh，这个步骤我就不讲了，网络上有很多的博客是能写到的，所以如果配置好了ssh可以直接跳过这一步，如果没有配置的，应该是不想配置ssh的同学，请配置你的全局的git信息：</li></ol><ul><li>git config –golbal user.email “<a href="mailto:&#x79;&#x6f;&#117;&#64;&#x79;&#111;&#x75;&#x2e;&#x63;&#111;&#109;">&#x79;&#x6f;&#117;&#64;&#x79;&#111;&#x75;&#x2e;&#x63;&#111;&#109;</a>“</li><li>git config –golbal user.name “youname”</li></ul><ol start="3"><li>hexo generate (可以简写为hexo g)</li><li>hexo deploy (可以简写为 hexo d)<br>注意如果第四步出现了<code>ERROR Deployer not found: git</code>,说明你还没有为hexo安装git插件，需要运行<code>npm i hexo-deployer-git --save</code>进行安装。然后再执行第四部，然后就到你的github上面看看你的文件信息是否部署好。需要注意的是，因为hexo是部署上去的，而不是push上去的，所以只会把public里面的信息部署到上面，所以千万不要删除你本地的hexo文件，因为删除了就没有了，你如果想在git上面单独存储，可以开个仓库，单独存放。</li></ol></blockquote><h4 id="github上的配置"><a href="#github上的配置" class="headerlink" title="github上的配置"></a>github上的配置</h4><blockquote><p>文件部署完成以后，我们能看到仓库页面有个settings<br><img src="/img/setting_menu.jpg" alt="github 导航栏"><br>点击进去，设置你博客进入的入口地址<br><img src="/img/github_setting_url.jpg" alt="setting 页面"><br>这样就可以根据绿色条进入到你的博客地址当中去了！</p></blockquote><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><code>地址打开发现css等样式都是没有的，为什么呢？</code></li></ol><p>很多小伙伴可能在部署到github上以后打开生成好的url的时候，发现页面当中样式都是没有的，可能很疑惑，当然不需要太惊慌，可能是你的配置还没有把路径配置好<br>这时候，我们可以回到_config.yml当中，找到以下几个属性：<br>    - url: 你的url地址<br>    - root: 你的文件名，如果你没有另开文件夹，这里可以只设置-&gt; /</p><p>设置好以后，重新部署一下，就完美了，可以玩耍了~</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>以上都是从零开始搭建到上传github的过程，接下来说点其他的，hexo会存在默认的主题，或许很多小伙伴都不想跟人一样，想有点自己的主题特色，那就试试，hexo的主题设置吧~</p><blockquote><p>首先，你先进入到<a href="https://hexo.io/themes/">Hexo的主题专线</a><br>然后选择你想要的喜欢的Hexo的主题<br>点击进去，一般来说都能进入到该主题的github的页面，根据作者的文档进行主题的下载跟设置</p></blockquote><h3 id="写在最后的温馨提示"><a href="#写在最后的温馨提示" class="headerlink" title="写在最后的温馨提示"></a>写在最后的温馨提示</h3><p>由于本人血的教训，已经不下几次重新创建这个hexo博客了，最头疼的就是将本地的hexo推到远程以后，远程创建的只是一个hexo编译好的架构，一旦本地的hexo文件丢失，即使把远程的文件拉下来也没有用，依旧要重新init搭建一个hexo，没有任何方式找回丢失删除的hexo本地文件，这是血的教训，请使用hexo的各位小伙伴切记，你通过hexo命令推送了一版编译好的hexo博客的同时，请做好本地hexo文件的备份跟储存，非常重要！！！！切记！！！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
